<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Panel Interactivo de Parámetros de IA Generativa</title>
    <link rel="stylesheet" href="teamcubation.css">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body {
            font-family: var(--font-body);
            background-color: var(--light-gray);
            color: var(--dark-gray);
        }
        .tab-button {
            transition: all var(--transition-base);
            background-color: var(--white);
            color: var(--cold-main-violet);
            border: 1px solid var(--medium-gray);
        }
        .tab-button.active {
            background-color: var(--cold-main-violet);
            color: var(--white);
            box-shadow: var(--shadow-md);
        }
        .tab-button:not(.active):hover {
            background-color: var(--warm-secondary-yellow);
            color: var(--cold-secondary-violet);
        }
        .accordion-header {
            transition: background-color 0.2s ease-out;
        }
        .accordion-header:hover {
            background-color: var(--medium-gray);
        }
        .accordion-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.5s ease-in-out;
        }
        .accordion-item.open .accordion-content {
            max-height: 1500px; /* Ajustable */
        }
        .accordion-item.open .accordion-icon {
            transform: rotate(180deg);
        }
        .slider-track {
            background: var(--medium-gray);
        }
        .slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: var(--cold-main-violet);
            cursor: pointer;
            border-radius: 50%;
            border: 2px solid var(--white);
            box-shadow: var(--shadow-sm);
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: var(--cold-main-violet);
            cursor: pointer;
            border-radius: 50%;
            border: 2px solid var(--white);
            box-shadow: var(--shadow-sm);
            margin-top: -7px;
        }
        input[type=range]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: var(--cold-main-violet);
            cursor: pointer;
            border-radius: 50%;
            border: 2px solid var(--white);
            box-shadow: var(--shadow-sm);
        }
        .d3-chart-container text {
            font-family: var(--font-body);
            fill: var(--dark-gray);
        }
        .d3-chart-container .bar {
            transition: fill var(--transition-base), opacity var(--transition-base);
            fill: var(--medium-gray);
        }
        .d3-chart-container .bar.candidate {
            fill: var(--cold-main-violet);
            opacity: 0.6;
        }
        .d3-chart-container .bar.selected {
            fill: var(--white);
            stroke: var(--black);
            stroke-width: 3px;
        }
        .d3-chart-container .bar.sampling {
            fill: var(--cold-main-violet) !important;
            opacity: 0.85;
            filter: brightness(1.3) drop-shadow(0 0 8px var(--cold-main-violet));
            animation: samplePulse 0.3s ease-in-out;
        }
        .d3-chart-container .bar.final-selected {
            animation: selectToken 0.8s ease-out forwards;
        }
        @keyframes samplePulse {
            0%, 100% { 
                opacity: 0.85;
            }
            50% { 
                opacity: 1;
                filter: brightness(1.5) drop-shadow(0 0 12px var(--cold-main-violet));
            }
        }
        @keyframes selectToken {
            0% { 
                fill: var(--medium-gray);
                stroke: transparent;
                stroke-width: 0;
                opacity: 0.5;
            }
            30% {
                fill: var(--cold-main-violet);
                stroke: var(--black);
                stroke-width: 3px;
                opacity: 1;
                filter: brightness(1.3) drop-shadow(0 0 8px var(--black));
            }
            60% {
                fill: var(--cold-main-violet);
                stroke: var(--black);
                stroke-width: 4px;
                opacity: 1;
                filter: brightness(1.2) drop-shadow(0 0 6px var(--black));
            }
            100% { 
                fill: var(--cold-main-violet);
                stroke: var(--black);
                stroke-width: 3px;
                opacity: 1;
                filter: none;
            }
        }
        .d3-chart-container .axis path,
        .d3-chart-container .axis line {
            stroke: var(--dark-gray);
            opacity: 0.5;
        }
        .tooltip {
            position: absolute;
            text-align: center;
            padding: var(--spacing-xs) var(--spacing-sm);
            font-size: 0.75rem;
            background: var(--cold-main-violet);
            color: var(--white);
            border-radius: var(--radius-sm);
            pointer-events: none;
            opacity: 0;
            transition: opacity var(--transition-fast);
            box-shadow: var(--shadow-md);
        }
        header {
            background-color: var(--white);
            color: var(--dark-gray);
            border-bottom: 1px solid var(--medium-gray);
        }
        header h1 {
            color: var(--cold-main-violet);
        }
        #reset-btn {
            background-color: var(--white);
            border: 2px solid var(--cold-main-violet);
            color: var(--cold-main-violet);
        }
        #prepare-btn {
            background-color: var(--white);
            border: 2px solid var(--cold-main-violet);
            color: var(--cold-main-violet);
        }
        #select-btn,
        #generate-btn {
            background-color: var(--cold-main-violet);
            color: var(--white);
        }
        #select-btn:disabled {
            background-color: var(--medium-gray);
            color: var(--dark-gray);
            opacity: 0.6;
            cursor: not-allowed;
        }
        #generate-btn:hover,
        #select-btn:hover:not(:disabled) {
            opacity: 0.9;
            transform: translateY(-2px);
            box-shadow: var(--shadow-lg);
        }
        #reset-btn:hover,
        #prepare-btn:hover {
            background-color: var(--cold-main-violet);
            color: var(--white);
            transform: translateY(-2px);
            box-shadow: var(--shadow-lg);
        }
        .bg-neutral-light {
            background-color: var(--white);
        }
    </style>
</head>
<body class="min-h-screen p-2 sm:p-4 md:p-6">
    <div id="app" class="max-w-7xl mx-auto bg-white rounded-2xl shadow-xl overflow-hidden">
        <header class="p-4 sm:p-6 bg-purple-light border-b border-gray-200">
            <h1 class="text-2xl sm:text-3xl font-bold">Panel Interactivo de Parámetros de IA Generativa</h1>
            <p class="mt-1 text-sm">Guía interactiva técnica sobre Top-K, Top-P y Temperatura.</p>
        </header>

        <div class="p-4 sm:p-6">
            <!-- Pestañas -->
            <div class="flex border-b border-gray-300 mb-6">
                <button id="tab-demo" class="tab-button active text-sm sm:text-base font-semibold py-2 px-4 rounded-t-lg -mb-px">Demo interactiva</button>
                <button id="tab-concepts" class="tab-button text-sm sm:text-base font-semibold py-2 px-4 rounded-t-lg -mb-px">Explicaciones conceptuales</button>
            </div>

            <!-- Contenido de Pestañas -->
            <div id="content-demo">
                <div class="grid grid-cols-1 lg:grid-cols-5 gap-6">
                    <!-- Controles -->
                    <div class="lg:col-span-2 bg-neutral-light p-5 rounded-xl shadow-md">
                        <h2 class="text-xl font-bold mb-4 border-b pb-2">Controles de generación</h2>

                        <!-- Temperatura -->
                        <div class="mb-6">
                            <label for="temperature" class="block font-semibold mb-1">Temperatura: <span id="temperature-value" class="font-bold">0.70</span></label>
                            <p class="text-xs text-gray-500 mb-2">Controla qué tan predecible o creativa es la IA. Valores más altos = más creatividad.</p>
                            <input type="range" id="temperature" min="0.1" max="2.0" step="0.05" value="0.7" class="w-full h-1.5 bg-secondary-green rounded-lg appearance-none cursor-pointer slider-thumb">
                        </div>

                        <!-- Top K -->
                        <div class="mb-6">
                            <label for="top_k" class="block font-semibold mb-1">Top-K: <span id="top_k-value" class="font-bold">20</span></label>
                            <p class="text-xs text-gray-500 mb-2">Cantidad de opciones (tokens) más probables a considerar.</p>
                            <input type="range" id="top_k" min="1" max="50" step="1" value="20" class="w-full h-1.5 bg-secondary-green rounded-lg appearance-none cursor-pointer slider-thumb">
                        </div>

                        <!-- Top P -->
                        <div class="mb-6">
                            <label for="top_p" class="block font-semibold mb-1">Top-P (Núcleo): <span id="top_p-value" class="font-bold">0.90</span></label>
                            <p class="text-xs text-gray-500 mb-2">Porcentaje de certeza para incluir opciones (0.9 = 90%).</p>
                            <input type="range" id="top_p" min="0.01" max="1.0" step="0.01" value="0.9" class="w-full h-1.5 bg-secondary-green rounded-lg appearance-none cursor-pointer slider-thumb">
                        </div>

                        <div class="mt-6">
                            <button id="reset-btn" class="w-full py-2 px-4 rounded-lg hover:bg-opacity-90 transition-colors">Reiniciar texto</button>
                        </div>
                    </div>

                    <!-- Área principal -->
                    <div class="lg:col-span-3">
                        <div class="bg-neutral-light p-5 rounded-xl shadow-md mb-6">
                            <label class="block font-semibold mb-2">Tu prompt:</label>
                            <div id="output-display" class="w-full p-3 bg-white border border-gray-200 rounded-lg min-h-[120px] text-lg leading-relaxed">
                                <span id="prompt-text">Había una vez, en una tierra lejana, vivía un</span><span id="generated-text"></span><span class="inline-block w-0.5 h-6 bg-primary-purple animate-pulse ml-0.5"></span>
                            </div>
                        </div>
                        <div class="bg-neutral-light p-5 rounded-xl shadow-md">
                            <div class="flex flex-col sm:flex-row justify-between items-start sm:items-center mb-2 gap-2">
                                <h2 class="text-xl font-bold">Probabilidades del siguiente token</h2>
                                <div class="flex gap-2 w-full sm:w-auto">
                                    <button id="prepare-btn" class="flex-1 sm:flex-none py-2 px-4 font-semibold rounded-lg transition-colors shadow-md">
                                        Analizar opciones
                                    </button>
                                    <button id="select-btn" class="flex-1 sm:flex-none py-2 px-4 font-semibold rounded-lg transition-colors shadow-md" disabled>
                                        Seleccionar token
                                    </button>
                                </div>
                            </div>
                            <p class="text-xs text-gray-500 mb-2">Visualización paso a paso. Las barras en <span class="font-semibold" style="color: var(--cold-main-violet);">violeta</span> son las candidatas para selección.</p>
                            <div id="selection-status" class="text-center py-2 mb-2 rounded-lg font-semibold text-sm transition-all duration-300" style="min-height: 36px; opacity: 0;">
                                <span id="status-text"></span>
                            </div>
                            <div id="chart-container" class="d3-chart-container w-full h-80"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div id="content-concepts" class="hidden">
                <div class="space-y-4">
                    <!-- Accordion Item 1 -->
                    <div class="accordion-item bg-neutral-light rounded-lg shadow-sm">
                        <div class="accordion-header flex justify-between items-center p-4 cursor-pointer">
                            <h3 class="text-lg font-semibold">Tokens</h3>
                            <svg class="accordion-icon w-6 h-6 transition-transform" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                        </div>
                        <div class="accordion-content">
                            <div class="p-4 border-t border-gray-200 prose max-w-none text-sm">
                                <p>Imaginá que la IA lee el texto como si fuera un rompecabezas de piezas. Los <strong>tokens</strong> son esas piezas individuales. A veces una pieza es una palabra completa como "casa", otras veces es solo un pedacito como "des-" o "anti-". La IA no lee letras sueltas como nosotros, sino que va juntando estas piezas para entender el mensaje.</p>
                                <p class="mt-2"><strong>Ejemplo práctico:</strong> La frase "descontento" podría dividirse en dos tokens: "des" + "contento", mientras que "feliz" podría ser un solo token completo.</p>
                            </div>
                        </div>
                    </div>
                    <!-- Accordion Item 2 -->
                    <div class="accordion-item bg-neutral-light rounded-lg shadow-sm">
                        <div class="accordion-header flex justify-between items-center p-4 cursor-pointer">
                            <h3 class="text-lg font-semibold">Temperatura</h3>
                            <svg class="accordion-icon w-6 h-6 transition-transform" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                        </div>
                        <div class="accordion-content">
                            <div class="p-4 border-t border-gray-200 prose max-w-none text-sm">
                                <p>Pensá en la <strong>temperatura</strong> como la perilla de "creatividad" de la IA. Es como cuando le pedís a alguien que complete una historia:</p>
                                <ul class="list-disc ml-5 mt-2">
                                    <li><strong>Temperatura baja (0.3):</strong> La IA siempre elige la opción más obvia y segura. Es como una persona re predecible que siempre dice lo esperado. Útil para respuestas precisas y consistentes.</li>
                                    <li><strong>Temperatura media (0.7-1.0):</strong> Balance entre predecible y sorprendente. La IA puede elegir opciones interesantes sin volverse demasiado rara.</li>
                                    <li><strong>Temperatura alta (1.5+):</strong> La IA se pone más "aventurera" y arriesgada. Como un poeta improvisando, puede crear cosas muy originales pero a veces medio sin sentido.</li>
                                </ul>
                                <p class="mt-2"><strong>Analogía:</strong> Si le preguntás a alguien "¿Qué mascota me recomendás?", con temperatura baja siempre te va a decir "perro" o "gato". Con temperatura alta capaz te sugiere "un dragón barbudo" o "una alpaca miniatura".</p>
                            </div>
                        </div>
                    </div>
                    <!-- Accordion Item 3 -->
                    <div class="accordion-item bg-neutral-light rounded-lg shadow-sm">
                        <div class="accordion-header flex justify-between items-center p-4 cursor-pointer">
                            <h3 class="text-lg font-semibold">Top-K</h3>
                            <svg class="accordion-icon w-6 h-6 transition-transform" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                        </div>
                        <div class="accordion-content">
                            <div class="p-4 border-t border-gray-200 prose max-w-none text-sm">
                                <p>Imaginá que la IA tiene una lista de 1000 palabras posibles para continuar tu frase. <strong>Top-K</strong> es como decirle: "Mirá solo las mejores K opciones y elegí entre esas".</p>
                                <p class="mt-2"><strong>Ejemplo visual:</strong> Si escribiste "Me gusta comer..." y configurás Top-K = 5, la IA solo va a considerar las 5 opciones más populares como: "pizza", "pasta", "helado", "ensalada", "sushi". Se saltea las otras 995 opciones menos probables como "tornillos" o "nubes".</p>
                                <ul class="list-disc ml-5 mt-2">
                                    <li><strong>Top-K bajo (5-10):</strong> Opciones re seguras y predecibles.</li>
                                    <li><strong>Top-K medio (20-30):</strong> Más variedad manteniendo coherencia.</li>
                                    <li><strong>Top-K alto (50+):</strong> Mayor diversidad, pero puede incluir opciones medio raras.</li>
                                </ul>
                            </div>
                        </div>
                    </div>
                    <!-- Accordion Item 4 -->
                    <div class="accordion-item bg-neutral-light rounded-lg shadow-sm">
                        <div class="accordion-header flex justify-between items-center p-4 cursor-pointer">
                            <h3 class="text-lg font-semibold">Top-P (Muestreo Núcleo)</h3>
                            <svg class="accordion-icon w-6 h-6 transition-transform" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                        </div>
                        <div class="accordion-content">
                            <div class="p-4 border-t border-gray-200 prose max-w-none text-sm">
                                <p><strong>Top-P</strong> funciona diferente a Top-K. En lugar de contar opciones, va sumando "confianza" hasta llegar a un porcentaje.</p>
                                <p class="mt-2"><strong>Analogía del presupuesto:</strong> Imaginá que tenés un presupuesto del 90% de certeza (Top-P = 0.9). La IA va sumando las opciones más probables hasta "gastar" ese 90%:</p>
                                <ul class="list-disc ml-5 mt-2">
                                    <li>Pizza: 50% de certeza (Total: 50%)</li>
                                    <li>Pasta: 25% de certeza (Total: 75%)</li>
                                    <li>Helado: 15% de certeza (Total: 90%) ✓ ¡Presupuesto completo!</li>
                                    <li>Sushi: 5% (ya no se considera)</li>
                                </ul>
                                <p class="mt-2">Con Top-P = 0.9, la IA elegiría entre Pizza, Pasta o Helado. Si hubiera una opción muy dominante (Pizza 85%), incluiría menos opciones. Es más inteligente que Top-K porque se adapta a cada situación.</p>
                                <p class="mt-2"><strong>En la práctica:</strong> Top-P = 0.9 es como decir "dame opciones que en conjunto representen el 90% de probabilidad de andar bien".</p>
                            </div>
                        </div>
                    </div>
                    <!-- Accordion Item 5 -->
                    <div class="accordion-item bg-neutral-light rounded-lg shadow-sm">
                        <div class="accordion-header flex justify-between items-center p-4 cursor-pointer">
                            <h3 class="text-lg font-semibold">Mecanismo operativo de los LLMs</h3>
                            <svg class="accordion-icon w-6 h-6 transition-transform" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                        </div>
                        <div class="accordion-content">
                            <div class="p-4 border-t border-gray-200 prose max-w-none text-sm">
                                <p>¿Cómo funciona la IA cuando escribe? Imaginá que está completando una frase palabra por palabra, pensando mucho en cada paso. Acá está el proceso simplificado:</p>
                                <ol class="list-decimal ml-5 mt-2 space-y-2">
                                    <li><strong>Lee tu mensaje:</strong> La IA toma lo que escribiste y lo divide en piezas chicas (tokens) para entenderlo mejor.</li>
                                    <li><strong>Analiza el contexto:</strong> Como cuando estás leyendo una historia y te acordás de lo importante, la IA revisa todas las palabras anteriores y detecta qué es relevante para seguir.</li>
                                    <li><strong>Piensa en opciones:</strong> Genera una lista mental de todas las palabras que podrían venir después, cada una con un "puntaje" de qué tan apropiada es.</li>
                                    <li><strong>Aplica los filtros:</strong> Usa Temperatura, Top-K y Top-P para decidir qué tan creativa o predecible tiene que ser. Es como elegir entre "lo seguro" o "lo interesante".</li>
                                    <li><strong>Elige una palabra:</strong> De todas las opciones que quedaron, selecciona una (no siempre la más probable, por eso a veces sorprende).</li>
                                    <li><strong>Agrega y repite:</strong> La palabra elegida se suma al texto, y todo el proceso arranca de nuevo para la siguiente palabra.</li>
                                </ol>
                                <p class="mt-3"><strong>Analogía completa:</strong> Es como un escritor que va palabra por palabra, leyendo todo lo que ya escribió antes de decidir la próxima palabra, considerando varias opciones y eligiendo la que mejor encaja con el tono que quiere darle (serio, creativo, técnico, etc.).</p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- Elementos UI ---
            const tabDemo = document.getElementById('tab-demo');
            const tabConcepts = document.getElementById('tab-concepts');
            const contentDemo = document.getElementById('content-demo');
            const contentConcepts = document.getElementById('content-concepts');

            const tempSlider = document.getElementById('temperature');
            const tempValue = document.getElementById('temperature-value');
            const topKSlider = document.getElementById('top_k');
            const topKValue = document.getElementById('top_k-value');
            const topPSlider = document.getElementById('top_p');
            const topPValue = document.getElementById('top_p-value');

            const promptTextEl = document.getElementById('prompt-text');
            const generatedTextEl = document.getElementById('generated-text');
            const prepareBtn = document.getElementById('prepare-btn');
            const selectBtn = document.getElementById('select-btn');
            const resetBtn = document.getElementById('reset-btn');
            const selectionStatus = document.getElementById('selection-status');
            const statusText = document.getElementById('status-text');

            const initialPrompt = "Había una vez, en una tierra lejana, vivía un";
            
            // Estado para guardar entre pasos
            let currentCandidates = null;
            let currentTempProbs = null;

            // --- Lógica de pestañas ---
            tabDemo.addEventListener('click', () => {
                tabDemo.classList.add('active');
                tabConcepts.classList.remove('active');
                contentDemo.classList.remove('hidden');
                contentConcepts.classList.add('hidden');
            });

            tabConcepts.addEventListener('click', () => {
                tabConcepts.classList.add('active');
                tabDemo.classList.remove('active');
                contentConcepts.classList.remove('hidden');
                contentDemo.classList.add('hidden');
            });

            // --- Acordeón ---
            document.querySelectorAll('.accordion-header').forEach(header => {
                header.addEventListener('click', () => {
                    const accordionItem = header.parentElement;
                    accordionItem.classList.toggle('open');
                });
            });

            // --- Simulación ---
            const vocab = {
                'default': [
                    { token: ' el', prob: 0.3 }, { token: ' un', prob: 0.2 }, { token: ' y', prob: 0.15 },
                    { token: ' fue', prob: 0.1 }, { token: ' con', prob: 0.08 }, { token: ' él', prob: 0.05 },
                    { token: ' ella', prob: 0.04 }, { token: ' eso', prob: 0.03 }, { token: ' que', prob: 0.02 },
                    { token: ' para', prob: 0.01 }, { token: '.', prob: 0.01 }, { token: ',', prob: 0.01 }
                ],
                'un': [
                    { token: ' príncipe', prob: 0.25 }, { token: ' rey', prob: 0.20 }, { token: ' valiente caballero', prob: 0.15 },
                    { token: ' dragón', prob: 0.10 }, { token: ' panadero humilde', prob: 0.08 }, { token: ' mágico', prob: 0.05 },
                    { token: ' solitario', prob: 0.04 }, { token: ' poderoso', prob: 0.03 }, { token: ' misterioso', prob: 0.02 },
                    { token: ' pequeño', prob: 0.02 }, { token: ' gigante', prob: 0.01 }, { token: ' parlante', prob: 0.01 }
                ],
                'caballero': [
                    { token: ' que', prob: 0.3 }, { token: ' montaba', prob: 0.2 }, { token: ' luchó', prob: 0.15 },
                    { token: ' salvó', prob: 0.1 }, { token: ' descubrió', prob: 0.08 }, { token: ' llamado', prob: 0.05 },
                    { token: '.', prob: 0.05 }, { token: ',', prob: 0.04 }, { token: ' y', prob: 0.03 }
                ],
                'princesa': [
                    { token: ' que', prob: 0.3 }, { token: ' vivía', prob: 0.2 }, { token: ' fue', prob: 0.15 },
                    { token: ' soñaba', prob: 0.1 }, { token: ' llamada', prob: 0.08 }, { token: ' tenía', prob: 0.05 },
                    { token: '.', prob: 0.05 }, { token: ',', prob: 0.04 }, { token: ' y', prob: 0.03 }
                ],
                'dragón': [
                    { token: ' que', prob: 0.3 }, { token: ' custodiaba', prob: 0.2 }, { token: ' respiraba', prob: 0.15 },
                    { token: ' vivía', prob: 0.1 }, { token: ' aterrorizaba', prob: 0.08 }, { token: ' dormía', prob: 0.05 },
                    { token: '.', prob: 0.05 }, { token: ',', prob: 0.04 }, { token: ' y', prob: 0.03 }
                ]
            };

            function getContext(text) {
                const words = text.trim().split(/\s+/);
                const lastWord = words[words.length - 1].toLowerCase().replace(/[^a-záéíóúñü]/g, '');
                return vocab[lastWord] || vocab['default'];
            }

            function applyTemperature(probabilities, temp) {
                if (temp === 1.0) return probabilities;
                const tempProbs = probabilities.map(p => ({...p, prob: Math.exp(Math.log(p.prob) / temp) }));
                const sum = tempProbs.reduce((acc, p) => acc + p.prob, 0);
                return tempProbs.map(p => ({...p, prob: p.prob / sum }));
            }

            function getCandidates(probabilities, k, p) {
                let topKFiltered = probabilities.slice(0, k);

                let cumulativeProb = 0;
                let topPFiltered = [];
                for (const tokenProb of topKFiltered) {
                    if (cumulativeProb < p) {
                        topPFiltered.push(tokenProb);
                        cumulativeProb += tokenProb.prob;
                    } else {
                        break;
                    }
                }
                return topPFiltered;
            }

            function sampleToken(candidates) {
                const sum = candidates.reduce((acc, c) => acc + c.prob, 0);
                const normalizedCandidates = candidates.map(c => ({...c, prob: c.prob / sum }));

                let rand = Math.random();
                let cumulative = 0;
                for (const candidate of normalizedCandidates) {
                    cumulative += candidate.prob;
                    if (rand < cumulative) {
                        return candidate.token;
                    }
                }
                return normalizedCandidates[normalizedCandidates.length - 1].token;
            }

            function updateStateAndViz() {
                const temp = parseFloat(tempSlider.value);
                const k = parseInt(topKSlider.value);
                const p = parseFloat(topPSlider.value);

                tempValue.textContent = temp.toFixed(2);
                topKValue.textContent = k;
                topPValue.textContent = p.toFixed(2);

                const fullText = promptTextEl.textContent + generatedTextEl.textContent;
                const baseProbs = [...getContext(fullText)];
                const tempProbs = applyTemperature(baseProbs, temp);
                const candidates = getCandidates(tempProbs, k, p);

                updateChart(tempProbs, candidates);
            }

            // PASO 1: Preparar y mostrar opciones
            async function prepareTokenSelection() {
                // Deshabilitar botones durante el proceso
                disableButton(prepareBtn);
                disableButton(selectBtn);
                
                showStatus('⚙️ Calculando probabilidades...', 'var(--secondary-green)');

                const temp = parseFloat(tempSlider.value);
                const k = parseInt(topKSlider.value);
                const p = parseFloat(topPSlider.value);

                const fullText = promptTextEl.textContent + generatedTextEl.textContent;
                const baseProbs = [...getContext(fullText)];
                const tempProbs = applyTemperature(baseProbs, temp);
                const candidates = getCandidates(tempProbs, k, p);

                if (candidates.length > 0) {
                    // Guardar estado para el siguiente paso
                    currentCandidates = candidates;
                    currentTempProbs = tempProbs;
                    
                    // Actualizar visualización
                    updateChart(tempProbs, candidates);
                    
                    await sleep(300);
                    
                    // Mostrar candidatos con animación suave
                    await animateShowCandidates(candidates);
                    
                    // Habilitar botón de selección
                    enableButton(selectBtn);
                    enableButton(prepareBtn);
                    
                    showStatus(`✅ ${candidates.length} candidatos listos para selección`, 'var(--secondary-green)');
                    
                    await sleep(2000);
                    hideStatus();
                } else {
                    enableButton(prepareBtn);
                    showStatus('⚠️ No hay candidatos disponibles', 'var(--primary-orange)');
                }
            }

            // PASO 2: Ejecutar la selección
            async function executeTokenSelection() {
                if (!currentCandidates || currentCandidates.length === 0) {
                    showStatus('⚠️ Primero analizá las opciones', 'var(--primary-orange)');
                    return;
                }

                // Deshabilitar botones
                disableButton(prepareBtn);
                disableButton(selectBtn);

                // Animar el proceso de selección
                await animateTokenSelection(currentCandidates);
                
                const selectedToken = sampleToken(currentCandidates);
                generatedTextEl.textContent += selectedToken;
                
                // Mostrar token seleccionado con animación
                await animateFinalSelection(currentTempProbs, currentCandidates, selectedToken);

                // Limpiar estado
                currentCandidates = null;
                currentTempProbs = null;

                // Habilitar solo el botón de preparar
                enableButton(prepareBtn);
            }

            function disableButton(btn) {
                btn.disabled = true;
                btn.style.opacity = '0.5';
                btn.style.cursor = 'not-allowed';
            }

            function enableButton(btn) {
                btn.disabled = false;
                btn.style.opacity = '1';
                btn.style.cursor = 'pointer';
            }

            async function animateShowCandidates(candidates) {
                const candidateTokens = candidates.map(c => c.token);
                
                showStatus('🔍 Identificando candidatos...', 'var(--primary-orange)');
                
                // Pulsar suavemente todas las candidatas
                svg.selectAll(".bar").classed("sampling", false);
                candidateTokens.forEach(token => {
                    svg.selectAll(".bar")
                        .filter(d => d.token === token)
                        .classed("sampling", true);
                });
                
                await sleep(800);
                
                svg.selectAll(".bar").classed("sampling", false);
            }

            async function animateTokenSelection(candidates) {
                const candidateTokens = candidates.map(c => c.token);
                const normalizedCandidates = candidates.map(c => ({...c, prob: c.prob / candidates.reduce((acc, x) => acc + x.prob, 0) }));
                
                // Mostrar estado: muestreando
                showStatus('🎲 Muestreando según probabilidades...', 'var(--primary-purple)');
                
                // "Ruleta" - iluminar barras según probabilidad
                const iterations = 10;
                for (let i = 0; i < iterations; i++) {
                    // Calcular cuál candidata resaltar según un muestreo
                    const rand = Math.random();
                    let cumulative = 0;
                    let highlightToken = candidateTokens[0];
                    
                    for (const candidate of normalizedCandidates) {
                        cumulative += candidate.prob;
                        if (rand < cumulative) {
                            highlightToken = candidate.token;
                            break;
                        }
                    }
                    
                    // Remover clases previas
                    svg.selectAll(".bar").classed("sampling", false);
                    
                    // Agregar clase a la barra seleccionada
                    svg.selectAll(".bar")
                        .filter(d => d.token === highlightToken)
                        .classed("sampling", true);
                    
                    await sleep(120);
                }
                
                svg.selectAll(".bar").classed("sampling", false);
            }

            async function animateFinalSelection(data, candidates, selectedToken) {
                // Mostrar token seleccionado
                showStatus(`✨ Token seleccionado: "${selectedToken}"`, 'var(--secondary-green)');
                
                updateChart(data, candidates, selectedToken);
                
                // Agregar animación final al token seleccionado
                svg.selectAll(".bar")
                    .filter(d => d.token === selectedToken)
                    .classed("final-selected", true);
                
                await sleep(800);
                
                svg.selectAll(".bar").classed("final-selected", false);
                
                // Ocultar status después de un momento
                await sleep(500);
                hideStatus();
            }

            function showStatus(message, color) {
                statusText.textContent = message;
                selectionStatus.style.backgroundColor = color + '15'; // 15% opacity
                selectionStatus.style.color = color;
                selectionStatus.style.border = `2px solid ${color}40`;
                selectionStatus.style.opacity = '1';
            }

            function hideStatus() {
                selectionStatus.style.opacity = '0';
            }

            function sleep(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }

            // --- Gráfico D3 ---
            const margin = { top: 20, right: 20, bottom: 80, left: 40 };
            const container = d3.select("#chart-container");
            const width = container.node().getBoundingClientRect().width - margin.left - margin.right;
            const height = container.node().getBoundingClientRect().height - margin.top - margin.bottom;

            const svg = container.append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);

            const x = d3.scaleBand().range([0, width]).padding(0.1);
            const y = d3.scaleLinear().range([height, 0]);

            const xAxis = svg.append("g").attr("transform", `translate(0,${height})`);
            const yAxis = svg.append("g");

            const tooltip = d3.select("body").append("div").attr("class", "tooltip");

            function updateChart(data, candidates, selectedToken = null) {
                const displayData = data.slice(0, 15); // Mostrar top 15
                const candidateTokens = new Set(candidates.map(c => c.token));

                x.domain(displayData.map(d => d.token));
                y.domain([0, d3.max(displayData, d => d.prob)]);

                xAxis.transition().duration(300).call(d3.axisBottom(x))
                    .selectAll("text")
                    .attr("transform", "rotate(-45)")
                    .style("text-anchor", "end");

                yAxis.transition().duration(300).call(d3.axisLeft(y).ticks(5, ".0%"));

                const bars = svg.selectAll(".bar").data(displayData, d => d.token);

                bars.exit().remove();

                bars.enter().append("rect")
                    .attr("class", "bar")
                    .attr("x", d => x(d.token))
                    .attr("width", x.bandwidth())
                    .attr("y", height)
                    .attr("height", 0)
                    .merge(bars)
                    .on("mouseover", (event, d) => {
                        tooltip.transition().duration(200).style("opacity", .9);
                        tooltip.html(`Token: "${d.token}"<br/>Prob: ${(d.prob * 100).toFixed(2)}%`)
                            .style("left", (event.pageX + 5) + "px")
                            .style("top", (event.pageY - 28) + "px");
                    })
                    .on("mouseout", () => {
                        tooltip.transition().duration(500).style("opacity", 0);
                    })
                    .transition().duration(300)
                    .attr("x", d => x(d.token))
                    .attr("width", x.bandwidth())
                    .attr("y", d => y(d.prob))
                    .attr("height", d => height - y(d.prob))
                    .attr("fill", "var(--green-light)")
                    .attr("class", d => {
                        let classes = "bar";
                        if (candidateTokens.has(d.token)) classes += " candidate";
                        if (d.token === selectedToken) classes += " selected";
                        return classes;
                    });
            }

            // --- Listeners ---
            [tempSlider, topKSlider, topPSlider].forEach(slider => {
                slider.addEventListener('input', () => {
                    updateStateAndViz();
                    // Si cambian parámetros, limpiar estado y deshabilitar botón de selección
                    if (currentCandidates) {
                        currentCandidates = null;
                        currentTempProbs = null;
                        disableButton(selectBtn);
                        hideStatus();
                    }
                });
            });

            prepareBtn.addEventListener('click', prepareTokenSelection);
            selectBtn.addEventListener('click', executeTokenSelection);

            resetBtn.addEventListener('click', () => {
                generatedTextEl.textContent = '';
                currentCandidates = null;
                currentTempProbs = null;
                disableButton(selectBtn);
                hideStatus();
                updateStateAndViz();
            });

            // Estado inicial
            promptTextEl.textContent = initialPrompt;
            updateStateAndViz();
        });
    </script>
</body>
</html>
