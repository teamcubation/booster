<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Visualización Interactiva de Modelos de Lenguaje - Teamcubation</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Montserrat:400,700&display=swap">
  <style>
    :root {
      --primary-a: #551872;
      --primary-b: #F34E1E;
      --secondary-a: #484848;
      --secondary-b: #8BDCB3;
      --gray-sec: #5A5A5A;
      --white: #fff;
      --panel-bg: #f6f6f6;
    }
    body {
      background: #f6f6f6;
      color: var(--secondary-a);
      font-family: 'Montserrat', Arial, sans-serif;
      margin: 0;
      min-height: 100vh;
    }
    .main-container {
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      padding: 2rem 1rem 3rem 1rem;
      min-height: 100vh;
      box-sizing: border-box;
    }
    header {
      margin-bottom: 2rem;
      text-align: center;
    }
    h1 {
      color: var(--primary-a);
      font-size: 2.2rem;
      margin-bottom: 0.3em;
      font-weight: 700;
    }
    .description {
      max-width: 520px;
      color: var(--gray-sec);
      font-size: 1.08rem;
    }
    .controls-panel {
      background: var(--white);
      border-radius: 20px;
      box-shadow: 0 2px 16px 0 rgba(72,72,72,0.08);
      padding: 1.2rem 2.2rem 1.2rem 2.2rem;
      margin-bottom: 2.1rem;
      display: flex;
      flex-wrap: wrap;
      gap: 2.2rem;
      justify-content: center;
      align-items: flex-end;
    }
    .control-group {
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      gap: 0.1rem;
      min-width: 130px;
    }
    .control-group label {
      font-weight: 700;
      color: var(--primary-a);
      margin-bottom: 2px;
      font-size: 1.02rem;
    }
    .control-group input[type='range'] {
      width: 150px;
      accent-color: var(--primary-b);
      margin-top: 4px;
    }
    .control-value {
      color: var(--primary-b);
      font-size: 1.05rem;
      font-weight: 700;
      margin-left: 4px;
    }
    .canvas-container {
      width: 100%;
      max-width: 730px;
      min-height: 420px;
      position: relative;
      background: var(--panel-bg);
      border-radius: 32px;
      box-shadow: 0 2px 16px 0 rgba(72,72,72,0.13);
      padding: 1.2rem;
      box-sizing: border-box;
      margin: 0 auto;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    canvas {
      width: 100% !important;
      height: auto !important;
      display: block;
      border-radius: 18px;
      box-shadow: 0 1px 9px 0 rgba(72,72,72,0.07);
      background: #fcfcfc;
    }
    /* Tooltips */
    .tooltip {
      display: none;
      position: fixed;
      background: var(--primary-a);
      color: var(--white);
      font-size: 0.99rem;
      padding: 7px 15px;
      border-radius: 12px;
      pointer-events: none;
      z-index: 999;
      box-shadow: 0 2px 8px 0 rgba(85, 24, 114, 0.09);
      max-width: 245px;
      line-height: 1.28;
    }
    .teamcubation-logo {
      position: fixed;
      left: 30px;
      bottom: 16px;
      display: flex;
      align-items: center;
      font-size: 1.08em;
      font-weight: 700;
      color: var(--primary-b);
      letter-spacing: -2px;
      z-index: 998;
    }
    @media (max-width: 900px) {
      .main-container {
        padding: 1.4rem 1vw 2.5rem 1vw;
      }
      .canvas-container {
        min-height: 325px;
        padding: 0.2rem;
        max-width: 97vw;
      }
    }
    @media (max-width: 600px) {
      .controls-panel {
        padding: 0.6rem 0.6rem;
        gap: 1.2rem;
      }
      .canvas-container {
        min-height: 210px;
        border-radius: 18px;
        padding: 0;
      }
      .teamcubation-logo {
        font-size: 0.93em;
        left: 10px;
        bottom: 7px;
      }
      h1 { font-size: 1.13rem; }
      .description { font-size: 0.98rem; }
    }
    @media (max-width: 440px) {
      .control-group input[type='range'] {
        width: 85px;
      }
      .teamcubation-logo { display: none; }
    }
  </style>
</head>
<body>
  <div class="main-container">
    <header>
      <h1>¿Cómo generan respuestas los Modelos de Lenguaje?</h1>
      <div class="description">Explorá cómo <strong>contexto</strong>, <strong>top-k</strong> y <strong>temperatura</strong> influyen, juntos, en la generación de texto de IA mediante conjuntos que se superponen. ¡Ajustá y descubrí visualmente el proceso!</div>
    </header>

    <div class="controls-panel">
      <div class="control-group">
        <label for="contexto">Contexto <span style="font-weight: 400">(tamaño ventana)</span></label>
        <input type="range" id="contexto" min="512" max="8192" step="16" value="2048">
        <span class="control-value" id="contextoVal">2048</span>
      </div>
      <div class="control-group">
        <label for="topk">Top-K <span style="font-weight: 400">(n mejores opciones)</span></label>
        <input type="range" id="topk" min="1" max="100" step="1" value="30">
        <span class="control-value" id="topkVal">30</span>
      </div>
      <div class="control-group">
        <label for="temp">Temperatura <span style="font-weight: 400">(creatividad)</span></label>
        <input type="range" id="temp" min="0.1" max="2.0" step="0.01" value="0.8">
        <span class="control-value" id="tempVal">0.80</span>
      </div>
    </div>

    <div class="canvas-container">
      <canvas id="vennCanvas" width="700" height="450" tabindex="0" aria-label="Visualización de conjuntos de parámetros IA" style="outline:none"></canvas>
      <div class="tooltip" id="tooltip"></div>
    </div>
  </div>
  <div class="teamcubation-logo">
    <svg width="32" height="20" viewBox="0 0 32 20" fill="none" xmlns="http://www.w3.org/2000/svg" style="margin-right: 8px;">
      <ellipse cx="10" cy="10" rx="9.7" ry="9.7" fill="#F34E1E"/>
      <ellipse cx="22" cy="10" rx="9.7" ry="9.7" fill="#F34E1E" opacity="0.55"/>
    </svg>
    teamcubation_
  </div>
  <script>
    // ----------------- LÓGICA DE INPUTS ------------------
    const contextoInput = document.getElementById('contexto');
    const topkInput = document.getElementById('topk');
    const tempInput = document.getElementById('temp');
    const contextoVal = document.getElementById('contextoVal');
    const topkVal = document.getElementById('topkVal');
    const tempVal = document.getElementById('tempVal');

    function updateLabels() {
      contextoVal.textContent = contextoInput.value;
      topkVal.textContent = topkInput.value;
      tempVal.textContent = parseFloat(tempInput.value).toFixed(2);
    }
    contextoInput.addEventListener('input', updateLabels);
    topkInput.addEventListener('input', updateLabels);
    tempInput.addEventListener('input', updateLabels);
    updateLabels();

    // ----------------- VISUALIZACIÓN: CANVAS ------------------
    const canvas = document.getElementById('vennCanvas');
    const ctx = canvas.getContext('2d');
    
    // Responsive resize:
    function resizeCanvas() {
      const parent = canvas.parentElement;
      let width = Math.min(parent.offsetWidth-10, 685);
      if(window.innerWidth < 600) width = Math.max(width, 260);
      const scale = window.devicePixelRatio || 1;
      canvas.width = width*scale;
      canvas.height = 0.64*width*scale;
      canvas.style.width = width+'px';
      canvas.style.height = (0.64*width)+'px';
    }
    window.addEventListener('resize', ()=>{resizeCanvas(); drawAll();});
    resizeCanvas();

    // Valores base
    let params = {
      contexto: parseInt(contextoInput.value),
      topk: parseInt(topkInput.value),
      temp: parseFloat(tempInput.value)
    };
    // Mapear valores a radios
    function mapParamToRadius(val, min, max, rMin, rMax) {
      return rMin + (rMax-rMin)*(val-min)/(max-min);
    }

    function drawVenn(params, width, height, animState) {
      ctx.clearRect(0,0,canvas.width,canvas.height);

      // Escalado retina
      ctx.save();
      const dpr = window.devicePixelRatio || 1;
      ctx.scale(dpr, dpr);

      // CENTRO VISUAL
      const cx = width*0.505, cy = height*0.55;

      // 1. Círculo "Conocimiento general mundo" (fondo gris)
      const worldR = Math.min(width, height)*0.44;
      ctx.globalAlpha = 0.23;
      ctx.beginPath();
      ctx.arc(cx, cy, worldR, 0, 2*Math.PI);
      ctx.fillStyle = '#5A5A5A';
      ctx.fill();
      ctx.globalAlpha = 1;
      // Etiqueta
      drawTag(cx-worldR*0.83, cy-worldR*0.55, 140, 'Conocimiento 
general IA', '#5A5A5A');

      // 2. Contexto (Violeta)
      // radio según contexto
      const ctxR = mapParamToRadius(
        animState.contexto, 512, 8192, worldR*0.29, worldR*0.99
      );
      // 3. Top-k (Naranja)
      // radio relativo a contexto, pero mucho menor
      const kR = mapParamToRadius(
        animState.topk, 1, 100, ctxR*0.23, ctxR*0.59
      );
      // 4. Temperatura (Verde agua - determina "zona de elección")
      // radio sobre el círculo top-k
      const tempR = mapParamToRadius(
        animState.temp, 0.1, 2.0, kR*0.17, kR*1.06
      );

      // PARA DIAGRAMA:
      // context: a la derecha, topk superpuesto adentro, temp centrado sobre topk
      const ctxX = cx+worldR*0.14, ctxY = cy;
      const kX = ctxX+ctxR*0.27, kY = ctxY;
      const tempX = kX, tempY = kY;

      // --- Top-K (Naranja, debajo de temp) ---
      ctx.globalAlpha = 0.31;
      ctx.beginPath();
      ctx.arc(kX, kY, kR, 0, 2*Math.PI);
      ctx.fillStyle = '#F34E1E';
      ctx.fill();
      ctx.globalAlpha = 1;
      // Etiqueta
      drawTag(kX+kR*0.40, kY-kR*0.11, 0, 'Top-K
(continuaciones probables)', '#F34E1E');

      // --- Contexto (violeta) ---
      ctx.globalAlpha = 0.34;
      ctx.beginPath();
      ctx.arc(ctxX, ctxY, ctxR, 0, 2*Math.PI);
      ctx.fillStyle = '#551872';
      ctx.fill();
      ctx.globalAlpha = 1;
      // Etiqueta
      drawTag(ctxX-ctxR*0.88, ctxY, 0, 'Contexto
(ventana activa)', '#551872');

      // --- Temperatura (verde agua) ---
      // Efecto: zona central iluminada/expandida según temp
      ctx.globalAlpha = 0.37;
      ctx.beginPath();
      ctx.arc(tempX, tempY, tempR, 0, 2*Math.PI);
      ctx.fillStyle = '#8BDCB3';
      ctx.fill();
      ctx.globalAlpha = 1;
      // Etiqueta
      drawTag(tempX, tempY+tempR*0.86, 0, 'Temperatura
(variedad/opciones)', '#15A880');

      // Zona seleccionada (respuesta): pequeña intersección central
      ctx.save();
      ctx.globalAlpha = 0.75;
      ctx.beginPath();
      ctx.arc(tempX, tempY, Math.max(tempR*0.19,13), 0, 2*Math.PI);
      ctx.fillStyle = '#15A880'; // verde oscuro secundario
      ctx.shadowColor = '#8BDCB3';
      ctx.shadowBlur = 12;
      ctx.fill();
      ctx.restore();
      // Etiqueta
      drawTag(tempX, tempY, 0, 'Zona
respuesta', '#15A880',16,true);

      // --- Efecto de creatividad según temperatura (ilumina bordes para temp alta):
      if(animState.temp > 1.1) {
        ctx.save();
        ctx.globalAlpha = Math.min(0.31 * (animState.temp-1.09),0.41);
        ctx.beginPath();
        ctx.arc(tempX, tempY, tempR*0.97, 0, 2*Math.PI);
        ctx.lineWidth = tempR*0.11;
        ctx.strokeStyle = '#00E095';
        ctx.shadowColor = '#4AF5BF';
        ctx.shadowBlur = 10*(animState.temp-1);
        ctx.stroke();
        ctx.restore();
      }
    
      ctx.restore();
      // Áreas para tooltips:
      return [
        {x: cx, y: cy, r: worldR, label: 'Conocimiento general IA:<br>El saber de fondo del modelo.'},
        {x: ctxX, y: ctxY, r: ctxR, label: 'Contexto:<br>Lo que el modelo "lee".<br>Más contexto = más info disponible.'},
        {x: kX, y: kY, r: kR, label: 'Top-K:<br>Cuántas opciones elige la IA entre las más probables.<br>Valores bajos generan resultados predecibles.'},
        {x: tempX, y: tempY, r: tempR, label: 'Temperatura:<br>Cambia creatividad y aleatoriedad.<br>Baja: más preciso. Alta: más creativo/riesgoso.'}
      ];
    }

    function drawTag(x, y, xoff, label, color, textSize=14,centered=false) {
      ctx.save();
      ctx.font = `700 ${textSize}px Montserrat,Arial,sans-serif`;
      ctx.textAlign = centered?'center':'left';
      ctx.textBaseline = 'middle';
      ctx.shadowBlur = 0;
      ctx.fillStyle = color;
      label = label.split('\n');
      for(let i=0; i<label.length; ++i) {
        ctx.fillText(label[i], x+xoff, y+i*textSize*1.18);
      }
      ctx.restore();
    }

    // ----------------- ANIMACIÓN SUAVE ------------------
    let animState = {
      contexto: params.contexto,
      topk: params.topk,
      temp: params.temp
    };
    function animateTo(target) {
      const s = animState;
      let needs = false;
      ['contexto','topk','temp'].forEach(k=>{
        if(Math.abs(s[k]-target[k])>0.005) needs=true;
      });
      if(!needs) return;
      const speed = 0.18;
      s.contexto += (target.contexto-s.contexto)*speed;
      s.topk += (target.topk-s.topk)*speed;
      s.temp += (target.temp-s.temp)*speed;
      requestAnimationFrame(()=>{drawAll(); animateTo(target)});
    }

    // Redibuja todo
    function drawAll() {
      let width = canvas.width/(window.devicePixelRatio||1), height = canvas.height/(window.devicePixelRatio||1);
      drawVenn(animState, width, height, animState);
    }

    // Cambio de parámetros
    function paramChange(){
      let newParams = {
        contexto: parseInt(contextoInput.value),
        topk: parseInt(topkInput.value),
        temp: parseFloat(tempInput.value)
      };
      params = newParams;
      animateTo(newParams);
    }
    contextoInput.addEventListener('input', paramChange);
    topkInput.addEventListener('input', paramChange);
    tempInput.addEventListener('input', paramChange);

    // Primer render
    drawAll();

    // ---- Tooltips (accesibles mouse y teclado) ----
    const tooltip = document.getElementById('tooltip');
    let lastAreas = [];
    function updateTooltip(e) {
      let rect = canvas.getBoundingClientRect();
      let mx, my;
      if(e.touches) { mx = e.touches[0].clientX-rect.left; my = e.touches[0].clientY-rect.top; }
      else { mx = e.clientX-rect.left; my = e.clientY-rect.top; }
      mx *= canvas.width/rect.width; my *= canvas.height/rect.height;
      mx /= (window.devicePixelRatio||1);
      my /= (window.devicePixelRatio||1);
      let hover = null;
      if(!lastAreas.length) {
        let width = canvas.width/(window.devicePixelRatio||1), height = canvas.height/(window.devicePixelRatio||1);
        lastAreas = drawVenn(params, width, height, animState);
      }
      for(const area of lastAreas) {
        const dx = mx-area.x, dy = my-area.y;
        if(dx*dx+dy*dy< area.r*area.r) hover = area;
      }
      if(hover) {
        tooltip.innerHTML = hover.label;
        tooltip.style.display = 'block';
        tooltip.style.left = (e.clientX+10)+'px';
        tooltip.style.top = (e.clientY-18)+'px';
      } else {
        tooltip.style.display = 'none';
      }
    }
    function clearTooltip() { tooltip.style.display = 'none'; }
    canvas.addEventListener('mousemove', updateTooltip);
    canvas.addEventListener('mouseleave', clearTooltip);
    canvas.addEventListener('touchmove', updateTooltip);
    canvas.addEventListener('touchend', clearTooltip);

    // Teclado: flechas para cambiar entre "focus" en círculos y Enter muestra info
    let currentFocus = -1;
    canvas.addEventListener('keydown', function(e) {
      if (!lastAreas.length) {
        let width = canvas.width/(window.devicePixelRatio||1), height = canvas.height/(window.devicePixelRatio||1);
        lastAreas = drawVenn(params, width, height, animState);
      }
      if(e.key==='Tab'||e.key==='ArrowRight') {
        e.preventDefault();
        currentFocus=(currentFocus+1)%lastAreas.length;
      } else if(e.key==='ArrowLeft') {
        currentFocus=(currentFocus-1+lastAreas.length)%lastAreas.length;
      } else if(e.key==='Enter'&&currentFocus>=0) {
        tooltip.innerHTML = lastAreas[currentFocus].label;
        tooltip.style.display = 'block';
        // Centramos tooltip sobre el círculo
        let rect = canvas.getBoundingClientRect(), a = lastAreas[currentFocus];
        let sx = rect.left + a.x*(rect.width/(canvas.width/(window.devicePixelRatio||1)));
        let sy = rect.top + a.y*(rect.height/(canvas.height/(window.devicePixelRatio||1)));
        tooltip.style.left = (sx-70)+'px';
        tooltip.style.top = (sy-34)+'px';
      }
      drawAll();
      if(currentFocus>=0) {
        let a = lastAreas[currentFocus];
        ctx.save();
        ctx.beginPath();
        ctx.arc(a.x,a.y,a.r,0,2*Math.PI);
        ctx.lineWidth = 4;
        ctx.strokeStyle = '#F34E1E';
        ctx.shadowColor = '#F34E1E';
        ctx.shadowBlur = 15;
        ctx.stroke();
        ctx.restore();
      }
    });
    canvas.addEventListener('blur',()=>{clearTooltip(); currentFocus=-1; drawAll();});
  </script>
</body>
</html>